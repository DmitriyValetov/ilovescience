{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "collapsed": false,
    "deletable": true,
    "editable": true
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<script>requirejs.config({paths: { 'plotly': ['https://cdn.plot.ly/plotly-latest.min']},});if(!window.Plotly) {{require(['plotly'],function(plotly) {window.Plotly=plotly;});}}</script>"
      ],
      "text/vnd.plotly.v1+html": [
       "<script>requirejs.config({paths: { 'plotly': ['https://cdn.plot.ly/plotly-latest.min']},});if(!window.Plotly) {{require(['plotly'],function(plotly) {window.Plotly=plotly;});}}</script>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "from networkx.drawing.nx_agraph import graphviz_layout\n",
    "from openpyxl import load_workbook\n",
    "from gensim.models import Word2Vec\n",
    "import matplotlib.pyplot as plt\n",
    "from matplotlib import cm\n",
    "import networkx as nx\n",
    "from numpy import *\n",
    "\n",
    "from plotly import tools\n",
    "import plotly.graph_objs as go\n",
    "import plotly.offline as off\n",
    "import csv\n",
    "\n",
    "%matplotlib inline\n",
    "off.init_notebook_mode(connected=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "collapsed": true,
    "deletable": true,
    "editable": true
   },
   "outputs": [],
   "source": [
    "def replics(model, target_word, topn=10):\n",
    "    return {word: model.wv.vocab[word].count\n",
    "                           for word in model.wv.vocab.keys()\n",
    "                           if word.find(target_word) == 0}\n",
    "\n",
    "\n",
    "def topics_normalize(model, raw_topics):\n",
    "    norm_topics = []\n",
    "    for word in raw_topics:\n",
    "        r = replics(model, word)\n",
    "        if r is not None:\n",
    "            norm_topics.append(max(r, key=r.get))\n",
    "        else:\n",
    "            norm_topics.append(None)\n",
    "\n",
    "    return norm_topics\n",
    "\n",
    "\n",
    "def sigmoid(x):\n",
    "    return 1 / (1 + math.exp(-x))\n",
    "\n",
    "\n",
    "def get_lines(fn):\n",
    "    return [line.strip() for line in open(fn, \"r\").readlines()]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "collapsed": true,
    "deletable": true,
    "editable": true
   },
   "outputs": [],
   "source": [
    "model = Word2Vec.load(\"../stat/word_vec/{section}.wordvec\")\n",
    "terms = topics_normalize(model, get_lines(\"../topics.txt\"))\n",
    "\n",
    "extented_terms = [x[0] for term in terms for x in model.most_similar([term], topn=5)]\n",
    "\n",
    "corr_path = \"../stat/frequency/{section}/terms_similar.csv\"\n",
    "corr = []\n",
    "with open(corr_path, \"rt\") as f:\n",
    "    reader = csv.reader(f)\n",
    "    next(f) \n",
    "    next(f)\n",
    "    for line in reader:\n",
    "        corr.append([float(x) for x in line[1:]])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true,
    "deletable": true,
    "editable": true
   },
   "outputs": [],
   "source": [
    "def color_convert(cmap, pl_entries):\n",
    "    h = 1.0/(pl_entries-1)\n",
    "    pl_colorscale = []\n",
    "    \n",
    "    for k in range(pl_entries):\n",
    "        C = list(map(uint8, array(cmap(k*h)[:3])*255))\n",
    "        pl_colorscale.append([k*h, 'rgb'+str((C[0], C[1], C[2]))])\n",
    "        \n",
    "    return pl_colorscale\n",
    "\n",
    "blues_cmap = cm.get_cmap('Blues')\n",
    "blues = color_convert(blues_cmap, 255)\n",
    "\n",
    "layout = go.Layout(\n",
    "    xaxis = dict(\n",
    "        ticktext=terms,\n",
    "        tickvals=[i for i in range(len(corr))],\n",
    "        tickangle=-45,\n",
    "        linewidth=1,\n",
    "        mirror=True\n",
    "    ),\n",
    "    yaxis = dict(\n",
    "        ticktext=terms,\n",
    "        tickvals=[i for i in range(len(corr))],\n",
    "        tickangle=-45,\n",
    "        linewidth=1,\n",
    "        mirror=True\n",
    "    ),\n",
    "    width = 500,\n",
    "    height = 500\n",
    "    )\n",
    "\n",
    "trace = go.Heatmap(z = corr,\n",
    "                   colorscale = blues,\n",
    "                   showscale = False)\n",
    "data=[trace]\n",
    "off.iplot({'data': data, 'layout': layout}, show_link=False);"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "collapsed": true,
    "deletable": true,
    "editable": true
   },
   "outputs": [],
   "source": [
    "def add_edges(G, unique_pairs, terms, model, min_dist):\n",
    "    w = []\n",
    "    for pair in unique_pairs:\n",
    "        word_one = terms[pair[0]]\n",
    "        word_two = terms[pair[1]]\n",
    "        dist = model.similarity(word_one, word_two)\n",
    "        if dist > min_dist:\n",
    "            w.append(edge_width)\n",
    "        else:\n",
    "            w.append(0)\n",
    "        G.add_edge(word_one, word_two)\n",
    "    return w"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true,
    "deletable": true,
    "editable": true
   },
   "outputs": [],
   "source": [
    "draw_method = \"neato\"\n",
    "min_dist1 = 0.3\n",
    "min_dist2 = 0.85\n",
    "font_small = 10\n",
    "font_large = 15\n",
    "\n",
    "terms_u = terms + extented_terms\n",
    "\n",
    "G = nx.Graph()\n",
    "G.add_nodes_from(terms_u)\n",
    "p = graphviz_layout(G, prog=draw_method)\n",
    "\n",
    "trace = go.Scatter(\n",
    "    x = [p[word][0] for word in terms_u],\n",
    "    y = [p[word][1] for word in terms_u],\n",
    "    mode = 'text',\n",
    "    name = 'None',\n",
    "    text = [\"<b>\" + x + \"</b>\" if x in terms else x for x in terms_u],\n",
    "    textposition = 'center',\n",
    "    textfont = {\n",
    "                \"size\": [font_large if x in terms else font_small for x in terms_u]\n",
    "            }\n",
    ")\n",
    "shapes = []\n",
    "unique_pairs = [[i, j] for j in range(len(terms_u)) for i in range(j)]\n",
    "\n",
    "for pair in unique_pairs:\n",
    "        word_one = terms_u[pair[0]]\n",
    "        word_two = terms_u[pair[1]]\n",
    "        dist = model.similarity(word_one, word_two)\n",
    "        if word_one in terms and word_two in terms:\n",
    "            if dist > min_dist1:\n",
    "                shapes.append({\n",
    "                    'type': 'line',\n",
    "                    'x0': p[word_one][0],\n",
    "                    'y0': p[word_one][1],\n",
    "                    'x1': p[word_two][0],\n",
    "                    'y1': p[word_two][1],\n",
    "                    'line': {\n",
    "                            'color': \"red\",\n",
    "                            'width': 1.0\n",
    "                            },\n",
    "                    'layer' : 'below',\n",
    "                    'opacity' : 0.65\n",
    "                    })\n",
    "        else:\n",
    "            if dist > min_dist2:\n",
    "                shapes.append({\n",
    "                    'type': 'line',\n",
    "                    'x0': p[word_one][0],\n",
    "                    'y0': p[word_one][1],\n",
    "                    'x1': p[word_two][0],\n",
    "                    'y1': p[word_two][1],\n",
    "                    'line': {\n",
    "                            'color': \"lightskyblue\",\n",
    "                            'width': 1.0\n",
    "                            },\n",
    "                    'layer' : 'below',\n",
    "                    'opacity' : 0.65\n",
    "                    })\n",
    "\n",
    "layout = go.Layout(\n",
    "    showlegend=False,\n",
    "    shapes = shapes,\n",
    "    xaxis=dict(\n",
    "        showgrid=False,\n",
    "        showticklabels = False,\n",
    "        zeroline=False),\n",
    "    yaxis=dict(\n",
    "        showgrid=False,\n",
    "        showticklabels = False,\n",
    "        zeroline=False),\n",
    "    width=700,\n",
    "    height=700,\n",
    "    hovermode= 'closest'\n",
    ")\n",
    "\n",
    "data = [trace]\n",
    "off.iplot({'data': data, 'layout': layout}, show_link=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {
    "collapsed": false,
    "deletable": true,
    "editable": true
   },
   "outputs": [],
   "source": [
    "n_words = 50        \n",
    "\n",
    "wb = load_workbook(filename = '../stat/frequency/{section}/topics.xlsx')\n",
    "\n",
    "sheet_list = wb.get_sheet_names()\n",
    "sheet_list.remove('uncovered')\n",
    "\n",
    "data = []\n",
    "for name in sheet_list:\n",
    "    ws = wb[name]\n",
    "    table = [[line[0].value, line[1].value, line[2].value] for line in \n",
    "                zip(ws.columns[0], ws.columns[1], ws.columns[2])]\n",
    "\n",
    "    labels = [line[0] for line in table]\n",
    "    x = [line[1] for line in table]\n",
    "    y = [line[2] for line in table]\n",
    "    \n",
    "    data.append(dict(\n",
    "                    type = 'scatter',\n",
    "                    x = [line[1] for line in table][:n_words],\n",
    "                    y = [line[2] for line in table][:n_words],\n",
    "                    mode = 'markers',\n",
    "                    hoverinfo = \"text\",\n",
    "                    hoveron = \"points\",\n",
    "                    name = name,\n",
    "                    text = [line[0] for line in table][:n_words]\n",
    "                ))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true,
    "deletable": true,
    "editable": true
   },
   "outputs": [],
   "source": [
    "layout = dict(\n",
    "        hovermode= 'closest',\n",
    "        xaxis=dict(title=\"tf-idf\"),\n",
    "        yaxis=dict(title=\"frequency\")\n",
    "        )\n",
    "\n",
    "off.iplot({'data': data, 'layout': layout}, validate=False, show_link=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true,
    "deletable": true,
    "editable": true
   },
   "outputs": [],
   "source": [
    "fn = \"../stat/lda/{section}.keys.csv\"\n",
    "\n",
    "def add_bar(fig, inp):\n",
    "    global chart_count\n",
    "    \n",
    "    if chart_count >= n_charts: \n",
    "        return\n",
    "    \n",
    "    labels = sorted([x[1] for x in topic_words])\n",
    "    values = sorted([x[0] for x in topic_words])\n",
    "    \n",
    "    data = go.Bar(\n",
    "            x=labels[:n_keys],\n",
    "            y=values[:n_keys],\n",
    "            orientation = 'h',\n",
    "            name = \"topic #{}\".format(chart_count + 1),\n",
    "            marker = marker\n",
    "    )\n",
    "    fig.append_trace(data, (chart_count // n_col) + 1, (chart_count % n_col) + 1)\n",
    "    fig['layout']['xaxis{0}'.format(chart_count+1)].update(showticklabels = False)\n",
    "    fig['layout']['yaxis{0}'.format(chart_count+1)].update(ticklen=3)\n",
    "    fig['layout']['yaxis{0}'.format(chart_count+1)]['tickfont'].update(size=11, \n",
    "                                                                       color=\"lightgrey\")\n",
    "    chart_count += 1 \n",
    "\n",
    "table = []\n",
    "val = []\n",
    "key = []\n",
    "with open(fn, \"rt\") as f:\n",
    "    reader = csv.reader(f)\n",
    "    next(f)    \n",
    "    for line in reader:\n",
    "        if len(line) == 1:\n",
    "            table.append([])\n",
    "        else:\n",
    "            table[-1].append([line[1], float(line[0])])\n",
    "\n",
    "n_row = 5\n",
    "n_col = 3\n",
    "chart_count = 0\n",
    "n_charts = n_row * n_col\n",
    "n_keys = 10\n",
    "\n",
    "marker=dict(color='orange')\n",
    "fig = tools.make_subplots(rows=n_row, cols=n_col, print_grid=False, \n",
    "                          horizontal_spacing = 0.15, vertical_spacing=0.05,\n",
    "                          subplot_titles=[x[0][0] for x in table[:n_charts]])\n",
    "\n",
    "for topic_words in table:\n",
    "    add_bar(fig, topic_words)\n",
    "    \n",
    "fig['layout'].update(height=750, width=750, showlegend=False)\n",
    "off.iplot(fig, show_link=False);"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 2",
   "language": "python",
   "name": "python2"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 2
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython2",
   "version": "2.7.13"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
